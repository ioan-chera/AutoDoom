// Emacs style mode select   -*- C++ -*-
//-----------------------------------------------------------------------------
//
// Copyright(C) 2015 Ioan Chera
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see http://www.gnu.org/licenses/
//
// Additional terms and conditions compatible with the GPLv3 apply. See the
// file COPYING-EE for details.
//
//-----------------------------------------------------------------------------
//
// DESCRIPTION:
//      Temporary bot map, processed to result into the final bot map
//
//-----------------------------------------------------------------------------

#include "../z_zone.h"
#include "b_analysis.h"
#include "b_botmap.h"
#include "b_botmaptemp.h"
#include "b_util.h"
#include "../a_doom.h"
#include "../ev_sectors.h"
#include "../ev_specials.h"
#include "../m_buffer.h"
#include "../m_compare.h"
#include "../p_info.h"
#include "../p_maputl.h"
#include "../p_setup.h"
#include "../p_spec.h"
#include "../r_main.h"
#include "../r_state.h"
#include "../v_misc.h"

enum
{
   BM_EPSILON = FRACUNIT / 2,
};

TempBotMap *tempBotMap;

////////////////////////////////////////////////////////////////////////////////
//
// TempBotMap builder intermediary classes
//
////////////////////////////////////////////////////////////////////////////////

//
// TempBotMapPImpl
//
// Private implementation
//
class TempBotMapPImpl : public ZoneObject
{
   TempBotMap *o;
public:
   //
   // LinePtrFlip
   //
   // Helper structure with Line pointer and flip flag
   //
   struct LinePtrFlip
   {
      TempBotMap::Line *lineref;  // line reference
      bool flipped;                 // was this line flipped?
      bool operator == (const LinePtrFlip &other) const
      {
         // needed for std::set
         return lineref == other.lineref;
         // 'flipped' not considered
      }
      struct Hash
      {
         size_t operator()(const LinePtrFlip &other) const
         {
            return std::hash<void *>()(other.lineref);
         }
      };
   };
   static LinePtrFlip makeLinePtrFlip (TempBotMap::Line *ptr)
   {
      LinePtrFlip ret;
      ret.lineref = ptr;
      // 'flipped' undefined!
      return ret;
   }
   static LinePtrFlip makeLinePtrFlip ( TempBotMap::Line *ptr, bool flip)
   {
      LinePtrFlip ret;
      ret.lineref = ptr;
      ret.flipped = flip;
      return ret;
   }
   typedef std::unordered_set<LinePtrFlip, LinePtrFlip::Hash> LinePtrFlipSet;

   //
   // RawLine
   //
   // Pre-line generated from BSP scanning, to be used to generate a final line.
   // Only connects simple sectors, and should only appear on non-standard
   // setups (vanilla doom deep water etc.)
   //
   struct RawLine
   {
      //const sector_t *sector[2];    // sector references
      v2fixed_t v[2];               // end point coordinates
      const line_t*     line;
   };
   
   //
   // RawMSector
   //
   // Pre-metasector generated by linedef
   //
   class RawMSector : public ZoneObject
   {
   public:
      v2fixed_t v[6];            // vertices, clockwise
      union
      {
         const line_t *lineGen;   // line which generated this
         const Mobj *mobjGen;     // thing which generated this
      };
      LinePtrFlipSet linerefs;
      int nvertices;             // commonly 4 or 6
      bool isFromMobj;
   };
private:
   //
   // BSPLineGen
   //
   // Helper class to generate the rawBSPLines collection. Contains the stack
   //
   class BSPLineGen : public ZoneObject
   {
      struct IndexedLineEq : LineEq
      {
         int ind;

         IndexedLineEq(double a, double b, double c, int ind) : LineEq(a, b, c), ind(ind)
         {
         }
         IndexedLineEq(const LineEq &le, int ind) : LineEq(le), ind(ind)
         {
         }
      };

      PODCollection<IndexedLineEq> linestack;    // stack of visited lines
      static PODCollection<v2fixed_t> proto;     // lists of colinear vertices
      Collection<PODCollection<v2fixed_t> > splitcoll;
      
      void recursiveGetLines(int nodenum);
   public:
      BSPLineGen()
      {
         splitcoll.setPrototype(&proto);
      }
      void startGetLines();
      void putLinesInColl(PODCollection<RawLine> &coll);
   };
   
public:
   PODCollection<RawLine> rawBSPLines;
   Collection<RawMSector> rawMSectors;
   
   TempBotMapPImpl(TempBotMap *owner) : o(owner)
   {
      static RawMSector rms;
      rawMSectors.setPrototype(&rms);
   }
   ~TempBotMapPImpl()
   {
   }
   
   void getBSPLines();
   void getLineMSectors();
   void getThingMSectors();
   
   void placeBSPLines();
   void placeMSecLines();
   
   void fillMSecRefs();
};
PODCollection<v2fixed_t> TempBotMapPImpl::BSPLineGen::proto;


//
// TempBotMapPImpl::BSPLineGen::recursiveGetLines
//
// Does a stack-wise obtaining of BSP lines
//
void TempBotMapPImpl::BSPLineGen::recursiveGetLines(int nodenum)
{
   if(nodenum & NF_SUBSECTOR)
      return;  // leaf, ignore
   const fnode_t &fnode = fnodes[nodenum];
   LineEq le(fnode);

   if(!le.valid())
      return;  // avoid degenerate nodes
   
   double dist1, dist2, dmin1, dmin2; // intersection point
   v2double_t v1 = {}, v2 = {};
   int imin1 = -1, imin2 = -1;
   dmin1 = dmin2 = DBL_MAX;
   
   for (IndexedLineEq *it = linestack.begin(); it != linestack.end(); ++it)
   {
      const LineEq &le2 = *it;
      v2double_t inters = le.intersection(le2);
      if (inters == v2double_invalid)
         continue;
      
      dist1 = fabs(inters.x - fnode.v[0].x) + fabs(inters.y - fnode.v[0].y);
      dist2 = fabs(inters.x - fnode.v[1].x) + fabs(inters.y - fnode.v[1].y);
      
      if (dist2 < dist1)
      {
         // closer to second vertex: forwards
         if (dist2 < dmin2)
         {
            dmin2 = dist2;
            v2 = inters;
            imin2 = it->ind;
         }
      }
      else
      {
         // closer to first vertex: backwards
         if (dist1 < dmin1)
         {
            dmin1 = dist1;
            v1 = inters;
            imin1 = it->ind;
         }
      }
   }

   v2fixed_t fv1 = v2fixed_t::doubleToFixed(v1);
   v2fixed_t fv2 = v2fixed_t::doubleToFixed(v2);
   
   // got them
   if (imin1 >= 0)
      splitcoll[imin1].add(fv1);
   if (imin2 >= 0)
      splitcoll[imin2].add(fv2);
   
   PODCollection<v2fixed_t> &sle = splitcoll.addNew();
   sle.add(fv1);
   sle.add(fv2);
   
   linestack.add({ le, (int)splitcoll.getLength() - 1 });
   recursiveGetLines(nodes[nodenum].children[0]);
   recursiveGetLines(nodes[nodenum].children[1]);
   linestack.pop();
}

//
// TempBotMapPImpl::BSPLineGen::recursiveGetLines
//
// Starts a stack-wise obtaining of BSP lines
//
void TempBotMapPImpl::BSPLineGen::startGetLines()
{
   // clear stack
   linestack.resize(0);
   
   // clear collection
   splitcoll.makeEmpty();
   
   // get map bounds
   v2fixed_t min, max;
   B_GetMapBounds(min, max);
   
   // add square bounds first
   linestack.add({ 1, 0, -M_FixedToDouble(min.x), -1 });  // x = minx
   linestack.add({ 0, 1, -M_FixedToDouble(max.y), -1 });  // y = maxy
   linestack.add({ 1, 0, -M_FixedToDouble(max.x), -1 });  // x = maxx
   linestack.add({ 0, 1, -M_FixedToDouble(min.y), -1 });  // y = miny

   // Do the work
   recursiveGetLines(numnodes - 1);
}

//
// TempBotMapPImpl::BSPLineGen::putLinesInColl
//
// Puts the lines, sorted, in the collection
//
void TempBotMapPImpl::BSPLineGen::putLinesInColl(PODCollection<RawLine> &coll)
{
   RawLine *newLine;
   v2fixed_t *oldv = NULL;
   for (PODCollection<v2fixed_t> *it = splitcoll.begin(); it != splitcoll.end();
        ++it)
   {
      // first, sort them
      std::sort(it->begin(), it->end(), LinePointCompare());
      
      v2fixed_t *jt = it->begin();
      oldv = jt;
      for (++jt; jt != it->end(); oldv = jt++)
      {
         v2fixed_t v[2];
         v[0] = *oldv;
         v[1] = *jt;
         if (D_abs(v[0].x - v[1].x) < BM_EPSILON &&
             D_abs(v[0].y - v[1].y) < BM_EPSILON)
         {
            continue;   // don't accept negligible lengths
         }
         const sector_t *sector[2];
         
         const v2fixed_t mid = {(v[0].x + v[1].x) / 2, (v[0].y + v[1].y) / 2};
         
         const angle_t ang = P_PointToAngle(v[0].x, v[0].y, v[1].x, v[1].y) -
         ANG90;
         sector[0] = R_PointInSubsector(mid.x + FixedMul(BM_EPSILON >> 2,
                                                B_AngleCosine(ang)),
                                                mid.y + FixedMul(BM_EPSILON >> 2,
                                                B_AngleSine(ang)))->sector;
         sector[1] = R_PointInSubsector(mid.x - FixedMul(BM_EPSILON >> 2,
                                                B_AngleCosine(ang)),
                                                mid.y - FixedMul(BM_EPSILON >> 2,
                                                B_AngleSine(ang)))->sector;
         if (sector[0] == sector[1])
         {
            // same sector, don't bother adding it
            continue;
         }
         newLine = &coll.addNew();
         newLine->v[0] = v[0];
         newLine->v[1] = v[1];
//         newLine->sector[0] = sector[0];
//         newLine->sector[1] = sector[1];
         newLine->line = nullptr;
//         printf("%g %g %g %g\n", M_FixedToDouble(newLine.v[0].x),
//                M_FixedToDouble(newLine.v[0].y),
//                M_FixedToDouble(newLine.v[1].x),
//                M_FixedToDouble(newLine.v[1].y));
         
      }
   }
}

//
// TempBotMapPImpl::getBSPLines
//
// Gets raw BSP lines from the map
//
void TempBotMapPImpl::getBSPLines()
{
   BSPLineGen linegen;
   
   linegen.startGetLines();
   linegen.putLinesInColl(rawBSPLines);
}

//
// TempBotMapPImpl::getLineMSectors
//
// Gets raw linedef metasectors from the map
//
void TempBotMapPImpl::getLineMSectors()
{
   V_SetLoading(numlines, "Map lines");

   for (int u = 0; u < numlines; ++u)
   {
      V_LoadingUpdateTicked(u + 1);

      const line_t &line = ::lines[u];
      const fixed_t x[2] = {line.v1->x, line.v2->x}, y[2] = {line.v1->y, line.v2->y};

      if (EV_IsWalkSpecial(line))
      {
          RawLine& rl = rawBSPLines.addNew();
         angle_t fineAngle = P_PointToAngle(x[0], y[0], x[1], y[1]) >> ANGLETOFINESHIFT;
         LineEq le(v2fixed_t(*line.v1), v2fixed_t(*line.v2)), axle[2];
         
         // No risk of dividing by zero, given the fine arrays

         // -pi/4 ... pi/4: x in (-16, 16), y in (-tan(a), +tan(a))
         // pi/4 ... 3pi/4: x in (-tan(a-pi/2), +tan(a-pi/2)), y in (-16, 16)
         // 3pi/4 ... 5pi/4: x in (16, -16), y in (tan(a-pi), -tan(a-pi))
         // 5pi/4 ... 7pi/4: x in (tan(a-3pi/2), -tan(a-3pi/2)), y in (16, -16)

         // ax + by + c = 0

         double dradius = M_FixedToDouble(o->radius);
         if(fineAngle >= FINEANGLES - SLOPERANGE / 2 || fineAngle < SLOPERANGE / 2)
         {
            // left->right             
             axle[0] = LineEq(1, 0, -(line.v1->fx - dradius));
             axle[1] = LineEq(1, 0, -(line.v2->fx + dradius));
         }
         else if(fineAngle >= SLOPERANGE / 2 && fineAngle < 3 * SLOPERANGE / 2)
         {
             // bottom->up
             axle[0] = LineEq(0, 1, -(line.v1->fy - dradius));
             axle[1] = LineEq(0, 1, -(line.v2->fy + dradius));
         }
         else if(fineAngle >= 3 * SLOPERANGE / 2 && fineAngle < 5 * SLOPERANGE / 2)
         {
             // right->left
             axle[0] = LineEq(1, 0, -(line.v1->fx + dradius));
             axle[1] = LineEq(1, 0, -(line.v2->fx - dradius));
         }
         else
         {
             // top->down
             axle[0] = LineEq(0, 1, -(line.v1->fy + dradius));
             axle[1] = LineEq(0, 1, -(line.v2->fy - dradius));
         }
         double ix[2], iy[2];
         if (!B_IntersectionPoint(le, axle[0], ix[0], iy[0]))
             I_Error("Invalid trigger walkover line extension detected!");
         if (!B_IntersectionPoint(le, axle[1], ix[1], iy[1]))
             I_Error("Invalid trigger walkover line extension detected!");

         rl.v[0].x = M_DoubleToFixed(ix[0]);
         rl.v[0].y = M_DoubleToFixed(iy[0]);
         rl.v[1].x = M_DoubleToFixed(ix[1]);
         rl.v[1].y = M_DoubleToFixed(iy[1]);

//          rl.sector[0] = line.frontsector;
//          rl.sector[1] = line.backsector;
          rl.line = &line;
      }
            
      if (line.frontsector == line.backsector &&
          !(line.flags & (ML_3DMIDTEX | ML_BLOCKING)) &&
            line.flags & ML_TWOSIDED)
      {
         // ugly check to not put this
         continue;
      }
      
//      printf("\n%d %d - %d %d:\n", x[0] >> 16, y[0] >> 16, x[1] >> 16, y[1] >> 16);

      RawMSector &rlms = rawMSectors.addNew();
      rlms.lineGen = &line;
      rlms.isFromMobj = false;

      const fixed_t minx = emin(x[0], x[1]);
      const fixed_t maxx = emax(x[0], x[1]);
      const fixed_t miny = emin(y[0], y[1]);
      const fixed_t maxy = emax(y[0], y[1]);

      switch(line.slopetype)
      {
         case ST_VERTICAL:
         {
            rlms.nvertices = 4;
            rlms.v[0].x = x[0] - o->radius;
            rlms.v[0].y = miny - o->radius;
            rlms.v[1].x = x[0] - o->radius;
            rlms.v[1].y = maxy + o->radius;
            rlms.v[2].x = x[0] + o->radius;
            rlms.v[2].y = maxy + o->radius;
            rlms.v[3].x = x[0] + o->radius;
            rlms.v[3].y = miny - o->radius;
            break;
         }
         case ST_HORIZONTAL:
         {
            rlms.nvertices = 4;
            rlms.v[0].x = minx - o->radius;
            rlms.v[0].y = y[0] - o->radius;
            rlms.v[1].x = minx - o->radius;
            rlms.v[1].y = y[0] + o->radius;
            rlms.v[2].x = maxx + o->radius;
            rlms.v[2].y = y[0] + o->radius;
            rlms.v[3].x = maxx + o->radius;
            rlms.v[3].y = y[0] - o->radius;
            break;
         }
         case ST_POSITIVE:
         {
            rlms.nvertices = 6;
            rlms.v[0].x = minx - o->radius;
            rlms.v[0].y = miny - o->radius;
            rlms.v[1].x = minx - o->radius;
            rlms.v[1].y = miny + o->radius;
            rlms.v[2].x = maxx - o->radius;
            rlms.v[2].y = maxy + o->radius;
            rlms.v[3].x = maxx + o->radius;
            rlms.v[3].y = maxy + o->radius;
            rlms.v[4].x = maxx + o->radius;
            rlms.v[4].y = maxy - o->radius;
            rlms.v[5].x = minx + o->radius;
            rlms.v[5].y = miny - o->radius;
            break;
         }
         case ST_NEGATIVE:
         {
            rlms.nvertices = 6;
            rlms.v[0].x = minx - o->radius;
            rlms.v[0].y = maxy + o->radius;
            rlms.v[1].x = minx + o->radius;
            rlms.v[1].y = maxy + o->radius;
            rlms.v[2].x = maxx + o->radius;
            rlms.v[2].y = miny + o->radius;
            rlms.v[3].x = maxx + o->radius;
            rlms.v[3].y = miny - o->radius;
            rlms.v[4].x = maxx - o->radius;
            rlms.v[4].y = miny - o->radius;
            rlms.v[5].x = minx - o->radius;
            rlms.v[5].y = maxy - o->radius;
            break;
         }
      }
   }
}

//
// TempBotMapPImpl::getThingMSectors
//
// Builds raw metasubsectors out of things
//
void TempBotMapPImpl::getThingMSectors()
{
   for(Thinker *th = thinkercap.next; th != &thinkercap; th = th->next)
   {
      Mobj *mo;
      
      if(!(mo = thinker_cast<Mobj *>(th)))
         continue;
      
      if(B_IsMobjSolidDecor(*mo))
      {
         RawMSector &rtms = rawMSectors.addNew();
         rtms.nvertices = 4;
         rtms.isFromMobj = true;
         rtms.mobjGen = mo;
         fixed_t boxradius = mo->radius + o->radius;
         rtms.v[0].x = mo->x - boxradius;
         rtms.v[0].y = mo->y - boxradius;
         rtms.v[1].x = mo->x - boxradius;
         rtms.v[1].y = mo->y + boxradius;
         rtms.v[2].x = mo->x + boxradius;
         rtms.v[2].y = mo->y + boxradius;
         rtms.v[3].x = mo->x + boxradius;
         rtms.v[3].y = mo->y - boxradius;
      }
   }
}

//
// TempBotMapPImpl::placeBSPLines
//
// Places lines for the raw BSP sources
//
void TempBotMapPImpl::placeBSPLines()
{
   V_SetLoading((int)rawBSPLines.getLength(), "Map BSP");
   for (int i = 0; i < (int)rawBSPLines.getLength(); ++i)
   {
      V_LoadingUpdateTicked(i + 1);
      const RawLine &rl = rawBSPLines[i];
      TempBotMap::Vertex &v1 = o->placeVertex(rl.v[0].x, rl.v[0].y);
      TempBotMap::Vertex &v2 = o->placeVertex(rl.v[1].x, rl.v[1].y);
      o->placeLine(v1, v2, rl.line);
   }
}

//
// BotManPImpl::placeMSecLines
//
// Places lines for the raw metasector sources
//
void TempBotMapPImpl::placeMSecLines()
{
   int numms = (int)rawMSectors.getLength();

   IntOSet simpleSet;
   TempBotMap::Vertex *v = NULL, *oldv = NULL, *firstv = NULL;

   V_SetLoading(numms, "Bot lines");
   for(int i = 0; i < numms; ++i)
   {
      V_LoadingUpdateTicked(i + 1);
      v = oldv = firstv = NULL;
      simpleSet.clear();
      simpleSet.insert(i);
      RawMSector &rms = rawMSectors[i];
      for (int j = 0; j < rms.nvertices; ++j)
      {
         oldv = v;
         v = &o->placeVertex(rms.v[j].x, rms.v[j].y);
         if(!firstv)
            firstv = v;
         if(oldv)
            o->placeLine(*oldv, *v, nullptr, &simpleSet);
      }
      o->placeLine(*v, *firstv, nullptr, &simpleSet);
   }
}

//
// TempBotMapPImpl::fillMSecRefs
//
// Fills the meta-sector references and clears the inner BSP lines
//
void TempBotMapPImpl::fillMSecRefs()
{
   TempBotMap::LinePtrSet visitedSet;
   IntOSet blockSet;
   PODCollection<TempBotMap::Line *> deletedColl;

   V_SetLoading((int)rawMSectors.getLength(), "Fill refs");
   for (int i = 0; i < (int)rawMSectors.getLength(); ++i)
   {
      V_LoadingUpdateTicked(i + 1);
      visitedSet.clear();
      blockSet.clear();

      // Gather blockmaps of its linedefs
      // FIXME: fill gaps on metasectors large enough
      RawMSector &rms = rawMSectors[i];
      for (auto jt = rms.linerefs.begin(); jt != rms.linerefs.end(); ++jt)
      {
         TempBotMap::Line &ln = *jt->lineref;
         blockSet.insert(ln.blockIndices.begin(), ln.blockIndices.end());
      }
      // Now look through the map blocks for foreign lines
      for (auto jt = blockSet.begin(); jt != blockSet.end(); ++jt)
      {
         deletedColl.makeEmpty();
         // Look through the lines in these mapblocks
         for (auto kt = o->lineBMap[*jt].begin();
              kt != o->lineBMap[*jt].end();
              ++kt)
         {
            // Alias the line to an easy name
            TempBotMap::Line &ln = **kt;
            if(visitedSet.count(&ln))  // was visited, so skip
               continue;
            visitedSet.insert(&ln);
            fixed_t x = ln.v1->x / 2 + ln.v2->x / 2;
            fixed_t y = ln.v1->y / 2 + ln.v2->y / 2;
            // This metasector is not part of it
            if(!ln.msecIndices[0].count(i) && !ln.msecIndices[1].count(i))
            {
               // See if it's inside. Look through all this rms' lines
               bool isInside = true;
               for (byte j = 0; j < rms.nvertices; ++j)
               {
                  
                  // Write coordinates and deltas into easy variables
                  fixed_t x1 = rms.v[j].x, y1 = rms.v[j].y;
                  fixed_t dx = rms.v[(j + 1) % rms.nvertices].x - x1;
                  fixed_t dy = rms.v[(j + 1) % rms.nvertices].y - y1;
                  if (B_PointOnLineSide(x, y, x1, y1, dx, dy))
                  {
                     // Middle of ln is outside. Consider the line outside
                     // FIXME: careful with slightly concave metasectors!
                     isInside = false;
                     break;   // get out of it
                  }
               }
               if(isInside)
               {
                  if (!ln.assocLine && !ln.msecIndices[0].size() && !ln.msecIndices[1].size())
                  {
                     deletedColl.add(&ln);
                  }
                  else
                  {
                     ln.msecIndices[0].insert(i);
                     ln.msecIndices[1].insert(i);
                  }
               }
               
            }
         }
         while(deletedColl.getLength() > 0)
         {
            o->deleteLine(deletedColl.pop(), NULL, NULL);
         }
      }
   }
}

//
// TempBotMap::deleteLine
//
// Deletes a line, cleaning everything up
//
void TempBotMap::deleteLine(Line *ln, IntOSet *targfront, IntOSet *targback)
{
   // erase line from all its links
   int i;
   for (i = 0; i < (int)ln->blockIndices.getLength(); ++i)
      lineBMap[ln->blockIndices[i]].erase(ln);

   TempBotMapPImpl::LinePtrFlip lpf = TempBotMapPImpl::makeLinePtrFlip(ln);
   for (byte j = 0; j < 2; ++j)
   {
      for (auto it = ln->msecIndices[j].begin();
           it != ln->msecIndices[j].end();
           ++it)
      {
         pimpl->rawMSectors[*it].linerefs.erase(lpf);
      }
   }
   
   --ln->v1->degree;
   --ln->v2->degree;
   lineList.remove(ln);
   --lineListSize;
   if(targfront)
      *targfront = std::move(ln->msecIndices[0]);
   if(targback)
      *targback = std::move(ln->msecIndices[1]);
   delete ln;
}

//
// TempBotMap::placeLine
//
// Places a line, making sure it fits with what's already there
//
TempBotMap::Line &TempBotMap::placeLine(Vertex &v1, Vertex &v2, const line_t* assocLine,
                                const IntOSet *msecGen, const IntOSet *bsecGen)
{
   // What can happen?
   // -- a line already exists between v1 and v2: just return that line
   for (auto it = lineBMap[v1.blockIndex].begin();
        it != lineBMap[v1.blockIndex].end();
        ++it)
   {
      Line &ln = **it;
      if(ln.v1 == &v1 && ln.v2 == &v2)
      {
         TempBotMapPImpl::LinePtrFlip lpf = TempBotMapPImpl::makeLinePtrFlip(&ln,
                                                                     false);
         if(msecGen)
         {
            for (auto it = msecGen->begin(); it != msecGen->end() ; ++it)
            {
               ln.msecIndices[0].insert(*it);
               pimpl->rawMSectors[*it].linerefs.insert(lpf);
            }
         }
         if(bsecGen)
         {
            lpf.flipped = true;
            for (auto it = bsecGen->begin(); it != bsecGen->end() ; ++it)
            {
               ln.msecIndices[1].insert(*it);
               pimpl->rawMSectors[*it].linerefs.insert(lpf);
            }
         }
         if (assocLine)
             ln.assocLine = assocLine;  // move it
         return ln;  // just return that
      }
      if(ln.v2 == &v1 && ln.v1 == &v2)
      {
         // reverse that, and return it
         TempBotMapPImpl::LinePtrFlip lpf = TempBotMapPImpl::makeLinePtrFlip(&ln, true);
         if(msecGen)
         {
            for (auto it = msecGen->begin(); it != msecGen->end() ; ++it)
            {
               ln.msecIndices[1].insert(*it);
               pimpl->rawMSectors[*it].linerefs.insert(lpf);
            }
         }
         if(bsecGen)
         {
            lpf.flipped = false;
            for (auto it = bsecGen->begin(); it != bsecGen->end() ; ++it)
            {
               ln.msecIndices[0].insert(*it);
               pimpl->rawMSectors[*it].linerefs.insert(lpf);
            }
         }
         if (assocLine)
             ln.assocLine = assocLine;  // move it
         return ln;
      }
   }
   
   // -- a vertex exist in this line's way, create two instead
   PODCollection<int> coll;
   botMap->getTouchedBlocks(v2fixed_t(v1), v2fixed_t(v2), [&coll](int b){
      coll.add(b);
   });

   // prepared these for bounds checking a bit later
   fixed_t maxx = botMap->bMapOrgX + botMap->bMapWidth * BOTMAPBLOCKSIZE;
   fixed_t maxy = botMap->bMapOrgY + botMap->bMapHeight * BOTMAPBLOCKSIZE;
   for (auto it = coll.begin(); it != coll.end(); ++it)
   {
      // scan each map block
      int b = *it;
      for (DLListItem<Vertex> *item = vertexBMap[b].head;
           item;
           item = item->dllNext)
      {
         Vertex &v = **item;
         // see if it isn't just one of the extremes
         if(&v == &v1 || &v == &v2)
            continue;

         v2fixed_t proj = B_ProjectionOnLine(v.x, v.y, v1.x, v1.y, v2.x - v1.x,
                                             v2.y - v1.y);
         // scan each vertex in a block
         if(D_abs(proj.x - v.x) < BM_EPSILON && D_abs(proj.y - v.y) < BM_EPSILON)
         {
            // intersecting, now see if inside
            if(FixedMul64(v.x - v1.x, v2.x - v.x) +
               FixedMul64(v.y - v1.y, v2.y - v.y) > 0)
            {
               // inside. Now recursively create inside until managed
               // let's hope it doesn't crash
               
               placeLine(v1, v, assocLine, msecGen, bsecGen);
               return placeLine(v, v2, assocLine, msecGen, bsecGen);
            }
         }
      }
      
      // -- another line will intersect it, create a vertex there and split them
      //    both
      
      double ix, iy;
      bool isInt;
      v2fixed_t inters;
      for (auto it = lineBMap[b].begin(); it != lineBMap[b].end(); ++it)
      {
         Line &ln = **it;
         isInt = B_IntersectionPoint(LineEq(v2fixed_t(v1), v2fixed_t(v2)),
                                          LineEq(v2fixed_t(*ln.v1), v2fixed_t(*ln.v2)),
                                          ix, iy);
         // bounds checking
         if(isInt && fabs(ix) < 32767 && fabs(iy) < 32767)
         {
            // intersection exists

            inters.x = M_DoubleToFixed(ix);
            inters.y = M_DoubleToFixed(iy);
            // bounds checking
            if(inters.x < botMap->bMapOrgX || inters.y < botMap->bMapOrgY ||
               inters.x > maxx || inters.y > maxy)
            {
               continue;
            }
            // is it inside both these lines?
            if (FixedMul64(inters.x - v1.x, v2.x - inters.x) +
                FixedMul64(inters.y - v1.y, v2.y - inters.y) > 0 &&
                FixedMul64(inters.x - ln.v1->x, ln.v2->x - inters.x) +
                FixedMul64(inters.y - ln.v1->y, ln.v2->y - inters.y) > 0)
            {
               // it is. Now can intersect
               // Create vertex
               Vertex &midv = placeVertex(inters.x, inters.y);
               // see if vertex ended up in the place of another already exis-
               // ting
               if(&midv == &v1)
               {
                  // intersecting me home.
                  // other line already split. So continue by adding normally
//                  goto justadd;
//                  return placeLine(v1, v2, bspIdx, msecGen, bsecGen);
                  continue;
               }
               if(&midv == &v2)
               {
                  // intersecting me on end.
                  // other line already split. So continue by adding normally
//                  goto justadd;
//                  return placeLine(v1, v2, bspIdx, msecGen, bsecGen);
                  continue;
               }
               placeLine(v1, midv, assocLine, msecGen, bsecGen);
               return placeLine(midv, v2, assocLine, msecGen, bsecGen);
            }
         }
      }
   }

   Line *ln = new Line;
   
//   Line *ln = estructalloc(Line, 1);
   ln->v1 = &v1;
   ln->v2 = &v2;
   ln->metasec[0] = NULL;
   ln->metasec[1] = NULL;
   ++v1.degree;
   ++v2.degree;
   
//   ln->blockIndices = ecalloc(int *, ln->numlinks = coll.getLength(),
//                              sizeof(int));
   ln->blockIndices.assign(std::move(coll));
   for (int i = 0; i < (int)ln->blockIndices.getLength(); ++i)
   {
      lineBMap[ln->blockIndices[i]].insert(ln);
   }
   TempBotMapPImpl::LinePtrFlip lpf = TempBotMapPImpl::makeLinePtrFlip(ln, false);
   if(msecGen)
   {
      ln->msecIndices[0] = *msecGen;
      
      for (auto it = ln->msecIndices[0].begin();
           it != ln->msecIndices[0].end();
           ++it)
      {
         pimpl->rawMSectors[*it].linerefs.insert(lpf);
      }
   }
   if(bsecGen)
   {
      ln->msecIndices[1] = *bsecGen;
      lpf.flipped = true;
      for (auto it = ln->msecIndices[1].begin();
           it != ln->msecIndices[1].end();
           ++it)
      {
         pimpl->rawMSectors[*it].linerefs.insert(lpf);
      }
   }
   ln->assocLine = assocLine;

   lpf.flipped = false;

   lineList.insert(ln);
   lineListSize++;
   
   return *ln;
}

//
// TempBotMap::placeVertex
//
// Adds a vertex to given coordinates, making sure to link it in blockmap.
// If it's already in blockmap, return that one instead of creating a new one
//
TempBotMap::Vertex &TempBotMap::placeVertex(fixed_t x, fixed_t y)
{
   int b = B_GetBlockCoords(x, y, botMap->bMapOrgX, botMap->bMapOrgY,
                            botMap->bMapWidth, BOTMAPBLOCKSIZE);
   
   for (DLListItem<Vertex> *item = vertexBMap[b].head;
        item;
        item = item->dllNext)
   {
      if (D_abs((*item)->x - x) < BM_EPSILON && D_abs((*item)->y - y) < BM_EPSILON)
         return **item;
   }
   int8_t m, n;
   for (m = -1; m < 2; ++m)
   {
      for (n = -1; n < 2; ++n)
      {
         if (!m && !n)  // don't revisit centre
            continue;
         int c = B_GetBlockCoords(x + m * BM_EPSILON, y + n * BM_EPSILON,
                                  botMap->bMapOrgX, botMap->bMapOrgY,
                                  botMap->bMapWidth, BOTMAPBLOCKSIZE);
         if(c != b)
         {
            for (DLListItem<Vertex> *item = vertexBMap[c].head;
                 item;
                 item = item->dllNext)
            {
               if (D_abs((*item)->x - x) < BM_EPSILON &&
                   D_abs((*item)->y - y) < BM_EPSILON)
               {
//                  printf("Found cross-block vertex merge %d %d (%d %d)\n",
//                         m, n, x>>FRACBITS, y>>FRACBITS);
                  return **item;
               }
            }
         }
      }
   }
   // not found there, create a new one
   
   // See if it sits on a line. Split it if so
   for (auto it = lineBMap[b].begin(); it != lineBMap[b].end(); ++it)
   {
      if(*it == NULL)   // sparse (deleted)
         continue;
      Line &ln = **it;
      v2fixed_t proj = B_ProjectionOnLine(x, y, ln.v1->x, ln.v1->y,
                                          ln.v2->x - ln.v1->x,
                                          ln.v2->y - ln.v1->y);
      if(D_abs(x - proj.x) < BM_EPSILON && D_abs(y - proj.y) < BM_EPSILON)
      {
         if(FixedMul64(x - ln.v1->x, ln.v2->x - x) +
            FixedMul64(y - ln.v1->y, ln.v2->y - y) > 0)
         {
            // inside the segment. Split it.
            Vertex *vert = estructalloc(Vertex, 1);
            vert->x = x;
            vert->y = y;
            vert->blockIndex = b;
            vert->degree = 0;
            Vertex &ov1 = *ln.v1, &ov2 = *ln.v2;
            
            IntOSet front, back;
            const line_t* assocLine = ln.assocLine;
            deleteLine(&ln, &front, &back);
            vertexList.insert(vert);
            vertexBMap[vert->blockIndex].insert(vert);
            
            placeLine(ov1, *vert, assocLine, &front, &back);
            placeLine(*vert, ov2, assocLine, &front, &back);
            return *vert;
         }
      }
   }
   Vertex *vert = estructalloc(Vertex, 1);
   vert->x = x;
   vert->y = y;
   vert->blockIndex = b;
   vert->degree = 0;
   vertexList.insert(vert);
   vertexBMap[b].insert(vert);
   
   return *vert;
}

//
// TempBotMap::createBlockMap
//
// Allocates the vertex and line blockmaps
//
void TempBotMap::createBlockMap()
{
   int bsz = botMap->bMapWidth * botMap->bMapHeight;
   
   typedef DLList<Vertex, &Vertex::blockLink> VertexList;
   
   vertexBMap = estructalloc(VertexList, bsz);
   for(int i = 0; i < bsz; ++i)
   {
      lineBMap.add();
   }
}

static void FindDynamicSectors(bool* dynamicSectors)
{
   // tagged sectors

   for(int i = 0; i < ::numlines; ++i)
   {
      const line_t &line = lines[i];
      
      if(!line.special)
         continue;
      
      // Has a special
      
      if(B_LineTriggersBackSector(line))
      {
         if(!line.backsector)
            continue;
         
         // Register back sector
         dynamicSectors[line.backsector - ::sectors] = true;
         continue;
      }
      
      // Must point to a tag, now
      if(!line.args[0])
         continue;
      
      // Not a door  type
      for(int secnum = -1; (secnum = P_FindSectorFromTag(line.args[0], secnum)) >= 0;)
      {
         dynamicSectors[secnum] = true;
         // Also do it for secondary sectors: from stairs or donuts
         const sector_t *sector = ::sectors + secnum;
         if(B_LineTriggersDonut(line) && sector->linecount)
         {
            const sector_t *sector2 = getNextSector(sector->lines[0], sector);
            if(sector2)
               dynamicSectors[sector2 - ::sectors] = true;
         }
         else if(B_LineTriggersStairs(line))
         {
            std::unordered_set<const sector_t *> stairSectors;
            stairSectors.insert(sector);
            bool continueStair;
            do
            {
               continueStair = false;
               for(int j = 0; j < sector->linecount; ++j)
               {
                  const sector_t *sector2 = sector->lines[j]->frontsector;
                  if(sector2 != sector || !(sector->lines[j]->flags & ML_TWOSIDED))
                     continue;

                  sector2 = sector->lines[j]->backsector;
                  if(!sector2 || sector2->srf.floor.pic != sector->srf.floor.pic || sector2 == sector ||
                     stairSectors.count(sector2))
                  {
                     continue;
                  }
                  
                  stairSectors.insert(sector2);
                  dynamicSectors[sector2 - ::sectors] = true;
                  sector = sector2;
                  continueStair = true;
               }
            }while(continueStair);
         }
      }
   }
   
   // 2. Find all sectors with timed effects
   for(int i = 0; i < ::numsectors; ++i)
   {
      const sector_t &sector = ::sectors[i];
      if(sector.tag == 666)  // any level can have KeenDie
      {
         dynamicSectors[i] = true;
         continue;
      }

      EVSectorSpecialFunc func;

      if(sector.tag == 667)
         for(int j = 0; j < NUM_BOSS_SPECS; ++j)
         {
            if(LevelInfo.bossSpecs & boss_specs[j].level_flag &&
               boss_specs[j].level_flag == BSPEC_MAP07_2)
            {
               dynamicSectors[i] = true;
               goto nextSector;
            }
         }

      if(!sector.special)
         continue;

      func = EV_GetSectorSpecial(sector);
      if(func == EV_SectorDoorRaiseIn5Mins || func == EV_SectorDoorCloseIn30)
         dynamicSectors[i] = true;
   nextSector:
      ;
   }
}


//
// TempBotMap::obtainMetaSectors
//
// This obtains meta sectors from
//
void TempBotMap::obtainMetaSectors()
{
   // remember to free this stuff
   bool* dynamicSectors = ecalloc(bool*, ::numsectors, sizeof(bool));
   
   FindDynamicSectors(dynamicSectors);
   
   
   //
   // MSecSetHash, MSecSetPred, mSecMap
   //
   // Map from a set of raw msector indices to a live MetaSector reference
   // Used to create a new (compound) MetaSector for every distinct combination
   // of indices
   //
   struct MSecSetHash
   {
      size_t operator()(const IntOSet *st) const
      {
         size_t h = 0;
         
		 // NOTE: this is poor, but hopefully should be valid
         for(auto it = st->cbegin(); it != st->cend(); ++it)
            h += (size_t)*it;
         
         return h;
      };
   };
   struct MSecSetPred
   {
      bool operator()(const IntOSet *st1, const IntOSet *st2) const
      {
         return *st1 == *st2;
      }
   };
   std::unordered_map<IntOSet *, MetaSector *, MSecSetHash, MSecSetPred>
   mSecMap;

   //
   // SecPtrHash, SecPtrPred
   //
   // For when using various pointers to sets
   //
   struct SecPtrHash
   {
	   size_t operator()(const std::set<MetaSector*> &st) const
	   {
		   uintptr_t h = 0;

		   for (auto it = st.cbegin(); it != st.cend(); ++it)
			   h = 5 * h + (uintptr_t)*it;

		   return std::hash<uintptr_t>()(h);
	   }
   };

   //
   // SecRefTuple, SecRefHash, SecRefPred, secRefs
   //
   // Contains sector reference and line-blocking information.
   // Used by line metasectors to combine together identical ones
   //
   struct SecRefTuple
   {
      const sector_t *sec[2];
      byte blocks;
      static SecRefTuple Make(const sector_t *s1, const sector_t *s2, byte blocks)
      {
         SecRefTuple ret;
         ret.sec[0] = s1 < s2 ? s1 : s2;
         ret.sec[1] = s1 < s2 ? s2 : s1;
         ret.blocks = blocks;
         return ret;
      }
   };
   struct SecRefHash
   {
      size_t operator()(const SecRefTuple &o) const
      {
         return std::hash<uintptr_t>()(5 * (5 * uintptr_t(o.sec[0]) + uintptr_t(o.sec[1])) + o.blocks);
      }
   };
   struct SecRefPred
   {
      bool operator()(const SecRefTuple &o1, const SecRefTuple &o2) const
      {
         return o1.blocks == o2.blocks &&
         o1.sec[0] == o2.sec[0] && o1.sec[1] == o2.sec[1];
      }
   };
   std::unordered_map<SecRefTuple, MetaSector *, SecRefHash, SecRefPred>
   secRefs;
   
   int msec_index = 0;

   // Create wall metasector
   LineMSector *wallms = new LineMSector;
   

   bool wallmsset = false;
   // (set its properties when first line is encountered)
   
   // coll, scoll: collection of either sector or line metasector references

   // Guidelines on these collections:
   // - coll maps raw metasector index to a finished metasector pointer
   // - scoll maps sector index to finished simple metasector pointer
   // Two indices can map to the same pointer, thus allowing lines to reference
   // the same finished metasector when they referenced different raw 
   // metasectors
   PODCollection<MetaSector *> coll, scoll;
   
   std::unordered_map<uint64_t, SimpleMSector*> simpleRepeatSet;
#define FLOORCEILING_HEIGHT(f, c) ((uint64_t)(f) + ((uint64_t)(c) << 32))
   
   // Get all sector metasectors
   scoll.reserve(numsectors);
   for (int i = 0; i < numsectors; ++i)
   {
      uint64_t comboHeight = FLOORCEILING_HEIGHT(::sectors[i].srf.floor.height,
                                                 ::sectors[i].srf.ceiling.height);
      // TODO: the other specials may count too
      bool isStatic = !dynamicSectors[i] && !::sectors[i].damage;
      
      if(isStatic && simpleRepeatSet.count(comboHeight))
      {
         scoll.add(simpleRepeatSet[comboHeight]);
         continue;
      }
      
      SimpleMSector *sms = new SimpleMSector;
      sms->sector = ::sectors + i;
      sms->listLink.dllData = msec_index++;
      msecList.insert(sms);
      
      if(isStatic)
      {
         simpleRepeatSet[comboHeight] = sms;
      }
      scoll.add(sms);
   }
   
#undef FLOORCEILING_HEIGHT
   
   // Get all thing or line metasectors
   
   // WARNING: each iteration must add an item to 'coll'.
   coll.reserve(pimpl->rawMSectors.getLength());
   V_SetLoading((int)pimpl->rawMSectors.getLength(), "MSEC RAW");
   for (auto it = pimpl->rawMSectors.begin(); it != pimpl->rawMSectors.end(); ++it)
   {
      V_LoadingUpdateTicked(eindex(it - pimpl->rawMSectors.begin()) + 1);
      const TempBotMapPImpl::RawMSector &rms = *it;
      if (rms.isFromMobj)
      {
         ThingMSector *tms = new ThingMSector;
         tms->sector = R_PointInSubsector(rms.mobjGen->x,
                                          rms.mobjGen->y)->sector;
         tms->mobj = rms.mobjGen;
         tms->listLink.dllData = msec_index++;
         msecList.insert(tms);
		 
         coll.add(tms);
      }
      else
      {
         if (!rms.lineGen->backsector)
         {
            // single-sided lines: always walls, not variant
            if(!wallmsset)
            {
               wallmsset = true;
               wallms->line = rms.lineGen;
               wallms->sector[0] = rms.lineGen->frontsector;
               wallms->sector[1] = nullptr;
			      wallms->listLink.dllData = msec_index++;
			      msecList.insert(wallms);

               botMap->nullMSec = wallms;
            }
            coll.add(wallms);
         }
         else
         {
            // two sided line
            SecRefTuple srt = SecRefTuple::Make(rms.lineGen->frontsector,
                                                rms.lineGen->backsector,
                                          !!(rms.lineGen->flags & ML_BLOCKING));
            
            // Avoid creating a new metasector if one with same references exists
            // Currently solid line metasectors are considered the same
            if (!secRefs.count(srt))
            {
               const sector_t* front = rms.lineGen->frontsector;
               const sector_t* back = rms.lineGen->backsector;
               if(!dynamicSectors[front - ::sectors]
                  && !dynamicSectors[back - ::sectors]
                  && !(rms.lineGen->flags & ML_BLOCKING))
               {
                  fixed_t deltaFloor, deltaCeiling;
                  deltaFloor = front->srf.floor.height - back->srf.floor.height;
                  deltaCeiling = front->srf.ceiling.height - back->srf.ceiling.height;

                  // B inside A: DC <= 0, DF >= 0
                  // A inside B: DC >= 0, DF <= 0
                  
                  MetaSector* ms = nullptr;
                  if(deltaCeiling <= 0 && deltaFloor >= 0)
                  {
                     // front inside back. Front wins
                     // Just use the simple metasector instead of a new line
                     // sector
                     ms = scoll[front - ::sectors];
                  }
                  else if(deltaCeiling >= 0 && deltaFloor <= 0)
                  {
                     ms = scoll[back - ::sectors];
                  }
                  
                  if(ms)
                  {
                     coll.add(ms);
                     secRefs[srt] = ms;
                     continue;
                  }
               }
               
               LineMSector *lms = new LineMSector;
               lms->sector[0] = front;
               lms->sector[1] = back;
               lms->line = rms.lineGen;
               lms->listLink.dllData = msec_index++;
               msecList.insert(lms);

               coll.add(lms);
               
               secRefs[srt] = lms;
            }
            else
               coll.add(secRefs[srt]);
         }
      }
   }
   
   DLListItem<Line> *item; // iteration item
   byte i;                 // various iteration indices
   int j;
   
   std::set<MetaSector *> cmsSet;   // set of metasectors to add to compound
   //std::unordered_map<std::set<MetaSector *> *, CompoundMSector *, SecPtrHash, SecPtrPred> cmsSetMap;
   std::unordered_map<std::set<MetaSector *>, MetaSector *, SecPtrHash> cmsSetMap;
   
   // Now visit each line and setup its metasector reference

   int lineListIndex = 1;
   V_SetLoading(lineListSize, "MSEC LINES");
   for (item = lineList.head; item; item = item->dllNext)
   {
      V_LoadingUpdateTicked(lineListIndex++);
      Line &ln = *item->dllObject;
      for (i = 0; i < 2; ++i)
      {
         if (!ln.msecIndices[i].size())   // No raw msec on this side of line
         {
            // just sector
            const v2fixed_t mid = {ln.v1->x / 2 + ln.v2->x / 2,
               ln.v1->y / 2 + ln.v2->y / 2};
            
            const angle_t ang = P_PointToAngle(ln.v1->x, ln.v1->y,
                                               ln.v2->x, ln.v2->y) +
            (i ? ANG90 : -ANG90);
            
            const sector_t *sector;
            sector = R_PointInSubsector(mid.x + FixedMul(BM_EPSILON >> 2,
                                                            B_AngleCosine(ang)),
                                        mid.y + FixedMul(BM_EPSILON >> 2,
                                                   B_AngleSine(ang)))->sector;
            ln.metasec[i] = scoll[sector - sectors];
         }
         else if(ln.msecIndices[i].size() == 1) // non-overlapped raw metasec
         {
            // single/direct one
            ln.metasec[i] = coll[*ln.msecIndices[i].begin()];
         }
         else
         {
            if (mSecMap.count(&ln.msecIndices[i])) // index set already mapped
            {
               // has value there
               MetaSector* ms = mSecMap.at(&ln.msecIndices[i]);
               ln.metasec[i] = ms;
            }
            else
            {
               cmsSet.clear();                     // reset reference set
               for (auto it = ln.msecIndices[i].begin();
                    it != ln.msecIndices[i].end();
                    ++it)
               {
                  if (coll[*it] == wallms)
                  {
                     // no back sector, so it's an outside wall, so just con-
                     // sider that
                     ln.metasec[i] = coll[*it];
                     mSecMap[&ln.msecIndices[i]] = ln.metasec[i];
                     goto nextLineSide;
                  }
                  cmsSet.insert(coll[*it]);        // add to set
               }
               if (cmsSet.size() == 1)             // only one distinct element
               {
                  // just use a simple line metasector
                  ln.metasec[i] = coll[*ln.msecIndices[i].begin()];
                  mSecMap[&ln.msecIndices[i]] = ln.metasec[i];
               }
               else
               {
                  if (cmsSetMap.count(cmsSet))
                  {
                     MetaSector *cms = cmsSetMap.at(cmsSet);
                     ln.metasec[i] = cms;
                     mSecMap[&ln.msecIndices[i]] = cms;
                  }
                  else
                  {
                     // First, check if all are simple metasectors and are static
                     bool allStatic = true;
                     fixed_t maxFloor = D_MININT, minCeiling = D_MAXINT;
                     SimpleMSector* floorSms = nullptr, *ceilingSms = nullptr;
                     
                     for(auto it = cmsSet.begin(); it != cmsSet.end(); ++it)
                     {
                        if(!(*it)->isInstanceOf(RTTI(SimpleMSector)))
                        {
                           allStatic = false;
                           break;
                        }
                        SimpleMSector* sms = runtime_cast<SimpleMSector*>(*it);
                        
                        if(dynamicSectors[sms->sector - ::sectors])
                        {
                           allStatic = false;
                           break;
                        }
                        
                        if(sms->sector->srf.floor.height > maxFloor)
                        {
                           maxFloor = sms->sector->srf.floor.height;
                           floorSms = sms;
                        }
                        if(sms->sector->srf.ceiling.height < minCeiling)
                        {
                           minCeiling = sms->sector->srf.ceiling.height;
                           ceilingSms = sms;
                        }
                     }
                     
                     if(allStatic && floorSms && floorSms == ceilingSms)
                     {
                        cmsSetMap[cmsSet] = floorSms;
                        
                        ln.metasec[i] = floorSms;
                        mSecMap[&ln.msecIndices[i]] = floorSms;
                     }
                     else
                     {
                        // create new metasector
                        CompoundMSector *cms = new CompoundMSector;
                        cms->msectors = emalloc(const MetaSector **,
                           (cms->numElem = static_cast<int>(cmsSet.size()))
                           * sizeof(const MetaSector *));

                        cmsSetMap[cmsSet] = cms;

                        j = 0;
                        for (auto it = cmsSet.begin(); it != cmsSet.end(); ++it, ++j)
                        {
                           cms->msectors[j] = *it;
                        }

                        cms->listLink.dllData = msec_index++;
                        msecList.insert(cms);

                        ln.metasec[i] = cms;
                        mSecMap[&ln.msecIndices[i]] = cms;
                     }
                  }
               }  // cmsSet.size()
            }  // mSecMap.count()
         }  // msecIndices[i].size()
      nextLineSide:
         ;
      }
      // Now clear memory of *SOME* intermediary data
      //ln.blockIndices.clear();
   }

   efree(dynamicSectors);
}


//
// TempBotMap::clearRedundantLines
//
// Clears lines with the same metasector reference on either side
//
void TempBotMap::clearRedundantLines()
{
   DLListItem<Line> *item, *next;
   for (item = lineList.head; item; item = next)
   {
      next = item->dllNext;
      Line &ln = *item->dllObject;
      if(!ln.assocLine && ln.metasec[0] == ln.metasec[1])
         deleteLine(&ln, NULL, NULL);
   }
}

//
// TempBotMap::clearUnusedVertices
//
// Removes vertices no longer used (degree 0)
//
void TempBotMap::clearUnusedVertices()
{
   DLListItem<Vertex> *item, *next;
   for (item = vertexList.head; item; item = next)
   {
      next = item->dllNext;
      if(!item->dllObject->degree)
      {
         vertexList.remove(*item);
         vertexBMap[item->dllObject->blockIndex].remove(*item);
         efree(*item);
      }
   }
}

//
// TempBotMap::TempBotMap
//
// Constructor
//
TempBotMap::TempBotMap() : generated(false), radius(0), vertexBMap(NULL),
lineListSize()
{
   vertexList.head = nullptr;
   lineList.head = nullptr;
   msecList.head = nullptr;

   pimpl = new TempBotMapPImpl(this);
   
   static LinePtrSet lineBMapProto;
   lineBMap.setPrototype(&lineBMapProto);
}

//
// TempBotMap::~TempBotMap
//
// Destructor
//
TempBotMap::~TempBotMap()
{
   {
      DLListItem<Vertex> *item, *next;
      for (item = vertexList.head; item != nullptr; item = next)
      {
         next = item->dllNext;
         efree(item->dllObject);
      }
   }
   {
      DLListItem<Line> *item, *next;
      for (item = lineList.head; item != nullptr; item = next)
      {
         next = item->dllNext;
         delete item->dllObject;
      }
   }
   {
      DLListItem<MetaSector> *item, *next;
      for (item = msecList.head; item != nullptr; item = next)
      {
         next = item->dllNext;
         delete item->dllObject;
      }
   }
   efree(vertexBMap);
   
   delete pimpl;
}

//
// TempBotMap::generateForRadius
//
// Generates the bot map, based on a given radius (commonly player's)
//
void TempBotMap::generateForRadius(fixed_t inradius)
{
//   clock_t CLK_STARTED = clock();
   if(generated)
      return;
   generated = true;
   radius = inradius;//-0x4000;// 0.25 = 0000 0000 0000 0000 0100 0000 0000 0000
   
   B_BEGIN_CLOCK
   pimpl->getBSPLines();
   B_MEASURE_CLOCK(getBSPLines)
   
   B_NEW_CLOCK
   pimpl->getLineMSectors();
   B_MEASURE_CLOCK(getLineMSectors)
   
   B_NEW_CLOCK
   pimpl->getThingMSectors();
   B_MEASURE_CLOCK(getThingMSectors)


   B_NEW_CLOCK
   createBlockMap();	// the tempbotmap part, derived from BotMap
   B_MEASURE_CLOCK(createBlockMap)
   
   B_NEW_CLOCK
   pimpl->placeBSPLines();
   B_MEASURE_CLOCK(placeBSPLines)
   
   B_NEW_CLOCK
   pimpl->placeMSecLines();
   B_MEASURE_CLOCK(placeMSecLines)

   B_NEW_CLOCK
   pimpl->fillMSecRefs();
   B_MEASURE_CLOCK(fillMSecRefs)

   B_NEW_CLOCK
   obtainMetaSectors();
   B_MEASURE_CLOCK(obtainMetaSectors)
   
   B_NEW_CLOCK
   clearRedundantLines();
   B_MEASURE_CLOCK(clearRedundantLines)
   
   B_NEW_CLOCK
   clearUnusedVertices();
   B_MEASURE_CLOCK(clearUnusedVertices)
   
//   checkVertices();
//   checkLines();
   
//   reduceVertices();
//   clock_t CLK_ENDED = clock();
//   printf("%lu\n", CLK_ENDED - CLK_STARTED);
}

// EOF

